<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortal PvP - Striker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #0a0a1a; font-family: 'Segoe UI', sans-serif; cursor: crosshair; }
        #gameCanvas { display: block; }

        #hud {
            position: fixed; top: 20px; left: 20px;
            color: white; z-index: 100;
        }
        .role-badge {
            padding: 8px 20px; border-radius: 20px; font-weight: bold;
            text-transform: uppercase; font-size: 1.1em; margin-bottom: 10px;
            display: inline-block;
        }
        .role-badge.blue { background: #3498db; }
        .role-badge.red { background: #e74c3c; }
        .stat-box { background: rgba(0,0,0,0.5); padding: 10px 15px; border-radius: 10px; margin: 5px 0; }
        .stat-label { font-size: 0.8em; color: #888; }
        .stat-value { font-size: 1.5em; font-weight: bold; }

        #crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 30px; height: 30px; z-index: 100; pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.8);
        }
        #crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
        #crosshair::after { height: 2px; width: 100%; top: 50%; transform: translateY(-50%); }

        #hitMarker {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; z-index: 101; pointer-events: none; opacity: 0;
        }
        #hitMarker.show { opacity: 1; }
        #hitMarker::before, #hitMarker::after {
            content: ''; position: absolute; background: #e74c3c; width: 3px; height: 20px;
        }
        #hitMarker::before { left: 50%; top: 0; transform: translateX(-50%) rotate(45deg); }
        #hitMarker::after { left: 50%; bottom: 0; transform: translateX(-50%) rotate(-45deg); }

        #weaponInfo {
            position: fixed; bottom: 30px; right: 30px;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 15px;
            color: white; z-index: 100;
        }
        #weaponName { font-size: 1.5em; font-weight: bold; }
        #ammoCount { font-size: 2em; margin-top: 5px; }

        #timer {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            font-size: 2em; font-weight: bold; color: white; z-index: 100;
        }

        #waitingOverlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9); display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 200;
        }
        #waitingOverlay.hidden { display: none; }
        #waitingOverlay h2 { margin-bottom: 20px; }
        #waitingOverlay p { color: #888; }

        #gameOverlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9); display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 300;
        }
        #gameOverlay.hidden { display: none; }
        #gameOverlay h1 { font-size: 3em; margin-bottom: 20px; }
    </style>
</head>
<body>
    <div id="waitingOverlay">
        <h2>‚öîÔ∏è PvP Mode - Striker</h2>
        <p>Connecting to host...</p>
        <p id="connectionStatus">Waiting...</p>
    </div>

    <div id="hud">
        <div class="role-badge" id="teamBadge">STRIKER</div>
        <div class="stat-box">
            <div class="stat-label">My Kills</div>
            <div class="stat-value" id="myKills">0</div>
        </div>
    </div>

    <div id="timer">5:00</div>
    <div id="crosshair"></div>
    <div id="hitMarker"></div>

    <div id="weaponInfo">
        <div id="weaponName">ASSAULT</div>
        <div id="ammoCount">‚àû</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="gameOverlay" class="hidden">
        <h1 id="winnerText">BLUE WINS!</h1>
        <div style="font-size: 1.5em; margin: 20px;">Your Kills: <span id="finalKills">0</span></div>
        <button onclick="location.reload()" style="padding: 15px 30px; font-size: 1.2em; border: none; border-radius: 10px; background: #3498db; color: white; cursor: pointer;">Play Again</button>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
    <script src="gameCore.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('room') || 'pvp-default';
        const myTeam = urlParams.get('team') || 'blue';

        document.getElementById('teamBadge').textContent = `${myTeam.toUpperCase()} STRIKER`;
        document.getElementById('teamBadge').className = `role-badge ${myTeam}`;

        let gameState = createGameState();
        let myKills = 0;
        let isConnected = false;

        // ==================== PEER CONNECTION ====================
        const peerId = `fortal_pvp_${roomId}_${myTeam}_striker`;
        const hostId = `fortal_pvp_${roomId}_blue_vanguard`;
        let peer = null;
        let hostConn = null;

        function initPeer() {
            peer = new Peer(peerId, { debug: 0 });

            peer.on('open', () => {
                document.getElementById('connectionStatus').textContent = 'Connecting to host...';
                connectToHost();
            });

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                document.getElementById('connectionStatus').textContent = 'Connection error: ' + err.type;
            });
        }

        function connectToHost() {
            hostConn = peer.connect(hostId, { reliable: true });

            hostConn.on('open', () => {
                isConnected = true;
                document.getElementById('connectionStatus').textContent = 'Connected! Waiting for game to start...';
            });

            hostConn.on('data', (data) => {
                if (data.type === 'sync') {
                    gameState = data.state;
                    if (gameState.gameStarted && document.getElementById('waitingOverlay').className !== 'hidden') {
                        startGame();
                    }
                    updateHUD();
                    if (gameState.gameEnded) showGameOver();
                } else if (data.type === 'gameStart') {
                    startGame();
                }
            });

            hostConn.on('close', () => {
                isConnected = false;
                document.getElementById('connectionStatus').textContent = 'Disconnected from host';
            });
        }

        function broadcast(data) {
            if (hostConn && hostConn.open) {
                hostConn.send(data);
            }
        }

        // ==================== THREE.JS ====================
        let scene, camera, renderer;
        let gridMeshes = [];
        let unitMeshes = {};

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 20, 80);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            createGrid();
        }

        function createGrid() {
            for (let y = 0; y < GAME_CONFIG.GRID_HEIGHT; y++) {
                gridMeshes[y] = [];
                for (let x = 0; x < GAME_CONFIG.GRID_WIDTH; x++) {
                    const geo = new THREE.BoxGeometry(GAME_CONFIG.CELL_SIZE - 0.05, 0.2, GAME_CONFIG.CELL_SIZE - 0.05);
                    const mat = new THREE.MeshStandardMaterial({ color: GAME_CONFIG.COLOR_NEUTRAL });
                    const cell = new THREE.Mesh(geo, mat);
                    cell.position.set(
                        (x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE,
                        0,
                        (y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE
                    );
                    gridMeshes[y][x] = cell;
                    scene.add(cell);
                }
            }
        }

        function updateVisuals() {
            // Update grid
            for (let y = 0; y < GAME_CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < GAME_CONFIG.GRID_WIDTH; x++) {
                    const state = gameState.grid[y] ? gameState.grid[y][x] : 0;
                    const cell = gridMeshes[y][x];
                    if (state === GAME_CONFIG.TEAM_BLUE) {
                        cell.material.color.setHex(GAME_CONFIG.COLOR_BLUE);
                    } else if (state === GAME_CONFIG.TEAM_RED) {
                        cell.material.color.setHex(GAME_CONFIG.COLOR_RED);
                    } else {
                        cell.material.color.setHex(GAME_CONFIG.COLOR_NEUTRAL);
                    }
                }
            }

            // Update units
            const allUnits = [...(gameState.units?.blue || []), ...(gameState.units?.red || [])];

            Object.keys(unitMeshes).forEach(id => {
                if (!allUnits.find(u => u.id === id)) {
                    scene.remove(unitMeshes[id]);
                    delete unitMeshes[id];
                }
            });

            allUnits.forEach(unit => {
                if (unit.state === 'dead') return;

                if (!unitMeshes[unit.id]) {
                    const color = unit.team === GAME_CONFIG.TEAM_BLUE ? 0x3498db : 0xe74c3c;
                    const size = unit.size * 0.5;
                    const geo = new THREE.SphereGeometry(size, 12, 12);
                    const mat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.userData = { unitId: unit.id, team: unit.team };
                    unitMeshes[unit.id] = mesh;
                    scene.add(mesh);
                }

                const mesh = unitMeshes[unit.id];
                mesh.position.set(
                    (unit.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE,
                    unit.size * 0.5,
                    (unit.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE
                );
            });

            // Update camera position (follow my team's vanguard or center)
            const myVanguard = gameState.players?.[myTeam]?.vanguard;
            if (myVanguard) {
                const targetX = (myVanguard.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
                const targetZ = (myVanguard.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
                camera.position.set(targetX, 10, targetZ + 15);
                camera.lookAt(targetX, 0, targetZ);
            }
        }

        function updateHUD() {
            document.getElementById('myKills').textContent = myKills;

            const mins = Math.floor((gameState.timeRemaining || 300) / 60);
            const secs = Math.floor((gameState.timeRemaining || 300) % 60);
            document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ==================== SHOOTING ====================
        document.addEventListener('click', () => {
            if (!gameState.gameStarted || gameState.gameEnded) return;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const enemyTeam = myTeam === 'blue' ? GAME_CONFIG.TEAM_RED : GAME_CONFIG.TEAM_BLUE;
            const targets = Object.values(unitMeshes).filter(m => m.userData.team === enemyTeam);

            const hits = raycaster.intersectObjects(targets);

            if (hits.length > 0) {
                const unitId = hits[0].object.userData.unitId;
                const damage = 25;

                broadcast({ type: 'shoot', team: myTeam, targetId: unitId, damage: damage });
                showHitMarker();
                myKills++;
                updateHUD();
            }
        });

        function showHitMarker() {
            const el = document.getElementById('hitMarker');
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 100);
        }

        // ==================== GAME LOOP ====================
        function startGame() {
            document.getElementById('waitingOverlay').classList.add('hidden');
            initThreeJS();
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            if (gameState.gameEnded) return;

            updateVisuals();
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        function showGameOver() {
            const blueWins = (gameState.stats?.blueTiles || 0) > (gameState.stats?.redTiles || 0);
            document.getElementById('winnerText').textContent = blueWins ? 'üîµ BLUE WINS!' : 'üî¥ RED WINS!';
            document.getElementById('winnerText').style.color = blueWins ? '#3498db' : '#e74c3c';
            document.getElementById('finalKills').textContent = myKills;
            document.getElementById('gameOverlay').classList.remove('hidden');
        }

        // ==================== INIT ====================
        window.addEventListener('resize', () => {
            if (renderer && camera) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
        });

        initPeer();
    </script>
</body>
</html>
