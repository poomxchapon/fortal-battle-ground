<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortal PvP - Vanguard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #0a0a1a;
            font-family: 'Segoe UI', sans-serif;
        }
        #gameCanvas { display: block; }

        /* Mobile Block */
        #mobileBlock {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 9999;
            padding: 20px;
        }
        #mobileBlock .icon { font-size: 4em; margin-bottom: 20px; }
        #mobileBlock h1 { font-size: 1.5em; margin-bottom: 10px; }
        #mobileBlock p { color: #888; max-width: 300px; }
        #mobileBlock.hidden { display: none; }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            color: white;
            z-index: 100;
        }
        .hud-section { display: flex; gap: 15px; align-items: center; }
        .role-badge {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            background: #9b59b6;
            font-size: 1.1em;
        }
        .role-badge.blue { background: #3498db; }
        .role-badge.red { background: #e74c3c; }
        .stat-box {
            background: rgba(255,255,255,0.1);
            padding: 8px 15px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-label { font-size: 0.7em; color: #888; text-transform: uppercase; }
        .stat-value { font-size: 1.3em; font-weight: bold; }

        /* Timer */
        #timer {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        #timer.warning { color: #e74c3c; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* Territory bar */
        #territoryBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            display: flex;
            z-index: 100;
        }
        #playerTerritory {
            background: linear-gradient(to right, #3498db, #2980b9);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-weight: bold;
        }
        #enemyTerritory {
            background: linear-gradient(to left, #e74c3c, #c0392b);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            padding-left: 10px;
            color: white;
            font-weight: bold;
        }

        /* Instructions */
        #instructions {
            position: fixed;
            bottom: 50px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 0.9em;
            z-index: 100;
        }
        #instructions h3 { color: #9b59b6; margin-bottom: 10px; }
        kbd {
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
            margin: 0 2px;
        }

        /* Connection */
        #connectionStatus {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            color: white;
            font-size: 0.85em;
            z-index: 100;
        }
        .dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .dot.online { background: #2ecc71; }
        .dot.offline { background: #666; }

        /* Game Over */
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }
        #gameOver.hidden { display: none; }
        #gameOver h1 { font-size: 4em; margin-bottom: 20px; }
        #gameOver .result { font-size: 2em; margin-bottom: 30px; }
        #gameOver .stats { font-size: 1.2em; color: #888; margin-bottom: 30px; }
        #gameOver .home-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        #gameOver .home-btn:hover { background: #2980b9; }

        /* Camera Controls */
        #cameraControls {
            position: fixed;
            bottom: 50px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }
        .cam-btn {
            padding: 10px 15px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #444;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .cam-btn:hover { border-color: #9b59b6; background: rgba(155,89,182,0.3); }
        .cam-btn.active { border-color: #9b59b6; background: rgba(155,89,182,0.5); }
        .cam-btn .icon { margin-right: 5px; }
    </style>
</head>
<body>
    <!-- Mobile Block Screen -->
    <div id="mobileBlock" class="hidden">
        <div class="icon">üñ•Ô∏è</div>
        <h1>Desktop Only</h1>
        <p>This game requires a desktop browser with keyboard and mouse. Please open on a computer.</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-section">
            <div class="role-badge" id="roleBadge">Vanguard <span style="opacity:0.6;font-size:0.7em">PvP</span></div>
            <div class="stat-box">
                <div class="stat-label">Room</div>
                <div class="stat-value" id="roomDisplay">---</div>
            </div>
        </div>
        <div id="timer">5:00</div>
        <div class="hud-section">
            <div class="stat-box">
                <div class="stat-label">Kills</div>
                <div class="stat-value" id="killCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Tiles</div>
                <div class="stat-value" id="tileCount">0</div>
            </div>
        </div>
    </div>

    <!-- Connection Status -->
    <div id="connectionStatus">
        <div style="color:#3498db;font-weight:bold;margin-bottom:5px;">üîµ Blue</div>
        <div><span class="dot online" id="blueVanguardDot"></span>Vanguard</div>
        <div><span class="dot offline" id="blueStrikerDot"></span>Striker</div>
        <div><span class="dot offline" id="blueCommanderDot"></span>Commander</div>
        <div style="color:#e74c3c;font-weight:bold;margin:8px 0 5px 0;">üî¥ Red</div>
        <div><span class="dot offline" id="redVanguardDot"></span>Vanguard</div>
        <div><span class="dot offline" id="redStrikerDot"></span>Striker</div>
        <div><span class="dot offline" id="redCommanderDot"></span>Commander</div>
    </div>

    <!-- Instructions -->
    <div id="instructions">
        <h3>VANGUARD - The Frontliner</h3>
        <p><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move</p>
        <p>Run to paint territory!</p>
        <p style="color:#9b59b6;margin-top:10px;">Permanent Rage Active</p>
    </div>

    <!-- Camera Controls -->
    <div id="cameraControls">
        <button class="cam-btn active" onclick="setCameraAngle(0)"><span class="icon">üîΩ</span>Top</button>
        <button class="cam-btn" onclick="setCameraAngle(1)"><span class="icon">üìê</span>2.5D</button>
        <button class="cam-btn" onclick="setCameraAngle(2)"><span class="icon">üëÅÔ∏è</span>Follow</button>
    </div>

    <!-- Territory Bar -->
    <div id="territoryBar">
        <div id="playerTerritory" style="width:50%;">50%</div>
        <div id="enemyTerritory" style="width:50%;">50%</div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOver" class="hidden">
        <h1 id="resultTitle">VICTORY!</h1>
        <div class="result" id="resultText">Your team controls 65% of the field!</div>
        <div class="stats" id="resultStats">Tiles painted: 234 | Team kills: 89</div>
        <button class="home-btn" onclick="location.href='lobby.html'">üè† Back to PvP Lobby</button>
    </div>

    <!-- Waiting Room -->
    <div id="waitingRoom">
        <div class="waiting-box">
            <h1>‚öîÔ∏è PVP MODE ‚öîÔ∏è</h1>
            <p class="room-code">Room: <span id="waitingRoomId">----</span></p>
            <p id="waitingMsg" style="color:#888;margin-bottom:20px;">Connecting...</p>

            <div class="teams-container" style="display:flex;gap:20px;">
                <!-- Blue Team -->
                <div class="team-box blue" style="flex:1;background:rgba(52,152,219,0.1);border:2px solid #3498db;border-radius:10px;padding:15px;">
                    <h3 style="color:#3498db;margin-bottom:10px;">üîµ BLUE TEAM</h3>
                    <div class="player-slot" id="slotBlueVanguard">
                        <span class="dot waiting"></span>
                        <span class="role-name">üèÉ Vanguard</span>
                        <span class="status">Waiting...</span>
                    </div>
                    <div class="player-slot" id="slotBlueStriker">
                        <span class="dot waiting"></span>
                        <span class="role-name">üî´ Striker</span>
                        <span class="status">Waiting...</span>
                    </div>
                    <div class="player-slot" id="slotBlueCommander">
                        <span class="dot waiting"></span>
                        <span class="role-name">üëë Commander</span>
                        <span class="status">Waiting...</span>
                    </div>
                </div>

                <!-- Red Team -->
                <div class="team-box red" style="flex:1;background:rgba(231,76,60,0.1);border:2px solid #e74c3c;border-radius:10px;padding:15px;">
                    <h3 style="color:#e74c3c;margin-bottom:10px;">üî¥ RED TEAM</h3>
                    <div class="player-slot" id="slotRedVanguard">
                        <span class="dot waiting"></span>
                        <span class="role-name">üèÉ Vanguard</span>
                        <span class="status">Waiting...</span>
                    </div>
                    <div class="player-slot" id="slotRedStriker">
                        <span class="dot waiting"></span>
                        <span class="role-name">üî´ Striker</span>
                        <span class="status">Waiting...</span>
                    </div>
                    <div class="player-slot" id="slotRedCommander">
                        <span class="dot waiting"></span>
                        <span class="role-name">üëë Commander</span>
                        <span class="status">Waiting...</span>
                    </div>
                </div>
            </div>

            <button id="startGameBtn" class="start-btn" disabled onclick="startGame()">
                Waiting for players...
            </button>
            <p class="host-note" id="hostNote">You are the HOST (Blue Vanguard)</p>
        </div>
    </div>

    <style>
        #waitingRoom {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        #waitingRoom.hidden { display: none; }
        .waiting-box {
            background: rgba(255,255,255,0.1);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            min-width: 350px;
        }
        .waiting-box h1 { margin-bottom: 10px; font-size: 1.5em; }
        .room-code { font-size: 1.5em; color: #f39c12; margin-bottom: 30px; }
        .room-code span { font-weight: bold; font-size: 1.3em; }
        .players-status { margin: 20px 0; text-align: left; }
        .players-status h3 { color: #888; margin-bottom: 15px; text-align: center; }
        .player-slot {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin: 8px 0;
        }
        .player-slot .dot {
            width: 12px; height: 12px;
            border-radius: 50%;
            background: #666;
        }
        .player-slot .dot.ready { background: #2ecc71; }
        .player-slot .dot.waiting { background: #666; animation: blink 1.5s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .player-slot .role-name { flex: 1; font-weight: bold; }
        .player-slot .status { color: #888; font-size: 0.85em; }
        .player-slot.ready .status { color: #2ecc71; }
        .start-btn {
            margin-top: 25px;
            padding: 15px 50px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            background: #666;
            color: white;
            cursor: not-allowed;
            transition: all 0.3s;
            width: 100%;
        }
        .start-btn:not(:disabled) {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            cursor: pointer;
        }
        .start-btn:not(:disabled):hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(46,204,113,0.4);
        }
        .host-note { margin-top: 15px; color: #9b59b6; font-size: 0.9em; }
    </style>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.152.0/build/three.min.js"></script>
    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Game Core -->
    <script src="../js/gameCore.js"></script>

    <script>
        // ==================== CONFIG ====================
        const params = new URLSearchParams(window.location.search);
        const ROOM_ID = params.get('room') || 'PVP-0000';
        const MY_TEAM = params.get('team') || 'blue';
        const MY_ROLE = 'vanguard';
        const IS_HOST = MY_TEAM === 'blue'; // Blue Vanguard is always the host

        // ==================== GAME STATE ====================
        let gameState = createGameState();
        initGrid(gameState);

        // PvP: Add red vanguard position
        gameState.players.redVanguard = {
            x: GAME_CONFIG.GRID_WIDTH / 2,
            y: 2, // Start at enemy side
            connected: false
        };

        // PvP: Track all 6 players
        gameState.pvpPlayers = {
            blue: { vanguard: IS_HOST, striker: false, commander: false },
            red: { vanguard: false, striker: false, commander: false }
        };

        if (IS_HOST) {
            gameState.pvpPlayers.blue.vanguard = true;
        }

        gameState.gameStarted = false;

        // Update UI for team
        document.getElementById('roleBadge').className = 'role-badge ' + MY_TEAM;
        document.getElementById('roleBadge').innerHTML = `${MY_TEAM.toUpperCase()} Vanguard <span style="opacity:0.6;font-size:0.7em">PvP</span>`;

        // ==================== NETWORKING ====================
        let peer = null;
        let connections = {};
        let hostConn = null; // For non-host players

        function initNetworking() {
            // PvP peer ID format: fortal_pvp_ROOMID_team_role
            const peerId = `fortal_pvp_${ROOM_ID}_${MY_TEAM}_vanguard`;
            console.log('Creating peer with ID:', peerId);

            peer = new Peer(peerId, { debug: 1 });

            peer.on('open', (id) => {
                console.log('‚úÖ Peer ready:', id);
                document.getElementById('roomDisplay').textContent = ROOM_ID;
                document.getElementById('waitingRoomId').textContent = ROOM_ID;

                if (IS_HOST) {
                    document.getElementById('waitingMsg').innerHTML = `Room <b>${ROOM_ID}</b> ready! Share this code.`;
                    document.getElementById('hostNote').textContent = 'You are the HOST (Blue Vanguard)';
                    updateWaitingRoom();
                } else {
                    // Red vanguard: connect to blue host
                    document.getElementById('waitingMsg').innerHTML = `Connecting to host...`;
                    document.getElementById('hostNote').textContent = 'Connecting to Blue Vanguard (Host)...';
                    connectToHost();
                }
            });

            peer.on('connection', (conn) => {
                console.log('üì• Incoming connection from:', conn.peer);
                handleConnection(conn);
            });

            peer.on('error', (err) => {
                console.error('‚ùå Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    document.getElementById('waitingMsg').innerHTML = `‚ö†Ô∏è Host not found! Make sure Blue Vanguard is in the room first. <button onclick="location.reload()">Retry</button>`;
                } else if (err.type === 'unavailable-id') {
                    document.getElementById('waitingMsg').innerHTML = `‚ö†Ô∏è Already connected! <button onclick="location.reload()">Refresh</button>`;
                } else {
                    document.getElementById('waitingMsg').innerHTML = `‚ö†Ô∏è Error: ${err.type} <button onclick="location.reload()">Retry</button>`;
                }
            });

            peer.on('disconnected', () => {
                console.log('‚ö†Ô∏è Disconnected, reconnecting...');
                peer.reconnect();
            });
        }

        function connectToHost() {
            const hostId = `fortal_pvp_${ROOM_ID}_blue_vanguard`;
            console.log('Connecting to host:', hostId);

            hostConn = peer.connect(hostId, { reliable: true });

            hostConn.on('open', () => {
                console.log('‚úÖ Connected to host!');
                document.getElementById('waitingMsg').innerHTML = `Connected! Waiting for game to start...`;
                document.getElementById('hostNote').textContent = 'Connected to Host';
                // Tell host we joined
                hostConn.send({ type: 'join', team: MY_TEAM, role: MY_ROLE });
            });

            hostConn.on('data', (data) => handleHostMessage(data));

            hostConn.on('close', () => {
                document.getElementById('waitingMsg').innerHTML = `‚ö†Ô∏è Disconnected from host! <button onclick="location.reload()">Reconnect</button>`;
            });
        }

        function handleConnection(conn) {
            // Parse peer ID: fortal_pvp_ROOMID_team_role
            const parts = conn.peer.split('_');
            const team = parts[3]; // blue or red
            const role = parts[4]; // vanguard, striker, commander
            const connKey = `${team}_${role}`;

            connections[connKey] = conn;

            conn.on('open', () => {
                console.log(`‚úÖ ${team} ${role} connected`);
                gameState.pvpPlayers[team][role] = true;
                updateConnectionUI();
                updateWaitingRoom();
                // Send current state
                conn.send({ type: 'sync', state: gameState });
            });

            conn.on('data', (data) => handleNetworkMessage(data, team, role));

            conn.on('close', () => {
                console.log(`‚ùå ${team} ${role} disconnected`);
                gameState.pvpPlayers[team][role] = false;
                updateConnectionUI();
                updateWaitingRoom();
            });
        }

        function broadcast(data) {
            Object.values(connections).forEach(conn => {
                if (conn.open) conn.send(data);
            });
        }

        // For non-host: send to host
        function sendToHost(data) {
            if (hostConn && hostConn.open) {
                hostConn.send(data);
            }
        }

        // ==================== WAITING ROOM ====================
        function updateWaitingRoom() {
            const p = gameState.pvpPlayers;

            // Update all 6 slots
            updateSlot('slotBlueVanguard', p.blue.vanguard, p.blue.vanguard ? (IS_HOST ? 'You (Host)' : 'Ready') : 'Waiting...');
            updateSlot('slotBlueStriker', p.blue.striker, p.blue.striker ? 'Ready' : 'Waiting...');
            updateSlot('slotBlueCommander', p.blue.commander, p.blue.commander ? 'Ready' : 'Waiting...');
            updateSlot('slotRedVanguard', p.red.vanguard, p.red.vanguard ? (MY_TEAM === 'red' ? 'You' : 'Ready') : 'Waiting...');
            updateSlot('slotRedStriker', p.red.striker, p.red.striker ? 'Ready' : 'Waiting...');
            updateSlot('slotRedCommander', p.red.commander, p.red.commander ? 'Ready' : 'Waiting...');

            // Count connected players
            const blueCount = [p.blue.vanguard, p.blue.striker, p.blue.commander].filter(x => x).length;
            const redCount = [p.red.vanguard, p.red.striker, p.red.commander].filter(x => x).length;
            const totalCount = blueCount + redCount;

            const btn = document.getElementById('startGameBtn');

            if (IS_HOST) {
                // Host can start when at least 1 player from each team
                if (blueCount >= 1 && redCount >= 1) {
                    btn.disabled = false;
                    btn.textContent = `START GAME (${totalCount}/6 players)`;
                } else {
                    btn.disabled = true;
                    btn.textContent = `Need players on both teams (Blue: ${blueCount}, Red: ${redCount})`;
                }
            } else {
                btn.disabled = true;
                btn.textContent = 'Waiting for host to start...';
            }
        }

        function updateSlot(slotId, isConnected, statusText) {
            const slot = document.getElementById(slotId);
            if (!slot) return;
            const dot = slot.querySelector('.dot');
            const status = slot.querySelector('.status');

            if (isConnected) {
                slot.classList.add('ready');
                dot.classList.remove('waiting');
                dot.classList.add('ready');
                status.textContent = statusText;
            } else {
                slot.classList.remove('ready');
                dot.classList.add('waiting');
                dot.classList.remove('ready');
                status.textContent = statusText;
            }
        }

        function startGame() {
            if (!IS_HOST || gameState.gameStarted) return;

            gameState.gameStarted = true;
            document.getElementById('waitingRoom').classList.add('hidden');

            // Broadcast game start
            broadcast({ type: 'gameStart', state: gameState });

            // Initial spawn (both teams controlled by players, no AI vanguards)
            spawnPlayerMinions(gameState);
            spawnEnemyMinions(gameState);
        }

        // Helper: Apply meteor damage and paint (myTeam paints, enemyTeam takes damage)
        function applyMeteor(state, x, y, myTeam, enemyTeam) {
            const radius = 5;
            const meteorDamage = 500;
            const enemyUnits = myTeam === GAME_CONFIG.TEAM_PLAYER ? state.units.enemy : state.units.player;
            const enemyBoss = myTeam === GAME_CONFIG.TEAM_PLAYER ? state.boss.enemy : state.boss.player;
            const killStat = myTeam === GAME_CONFIG.TEAM_PLAYER ? 'playerKills' : 'enemyKills';

            // Damage enemy units
            const remaining = enemyUnits.filter(unit => {
                const dist = Math.abs(unit.x - x) + Math.abs(unit.y - y);
                if (dist <= radius) {
                    if (unit.type === 'turret') {
                        unit.hp -= meteorDamage;
                        if (unit.hp <= 0) {
                            state.stats[killStat] = (state.stats[killStat] || 0) + 1;
                            return false;
                        }
                        return true;
                    }
                    state.stats[killStat] = (state.stats[killStat] || 0) + 1;
                    return false;
                }
                return true;
            });

            // Update the correct units array
            if (myTeam === GAME_CONFIG.TEAM_PLAYER) {
                state.units.enemy = remaining;
            } else {
                state.units.player = remaining;
            }

            // Damage enemy boss
            if (enemyBoss && enemyBoss.hp > 0) {
                const bossDist = Math.abs(enemyBoss.x - x) + Math.abs(enemyBoss.y - y);
                if (bossDist <= radius + 3) {
                    enemyBoss.hp -= meteorDamage;
                    if (enemyBoss.hp <= 0) {
                        enemyBoss.hp = 0;
                        enemyBoss.state = 'dead';
                        state.stats[killStat] = (state.stats[killStat] || 0) + 1;
                    }
                }
            }

            // Paint tiles with myTeam color
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const gx = Math.floor(x + dx);
                    const gy = Math.floor(y + dy);
                    if (gx >= 0 && gx < GAME_CONFIG.GRID_WIDTH &&
                        gy >= 0 && gy < GAME_CONFIG.GRID_HEIGHT) {
                        if (Math.abs(dx) + Math.abs(dy) <= radius) {
                            state.grid[gy][gx] = myTeam;
                        }
                    }
                }
            }
            updateTileCount(state);
        }

        // HOST: Handle messages from other players
        function handleNetworkMessage(data, senderTeam, senderRole) {
            switch(data.type) {
                case 'join':
                    gameState.pvpPlayers[data.team][data.role] = true;
                    if (data.team === 'red' && data.role === 'vanguard') {
                        gameState.players.redVanguard.connected = true;
                    }
                    updateConnectionUI();
                    updateWaitingRoom();
                    break;

                case 'redVanguardMove':
                    // Red vanguard position update
                    gameState.players.redVanguard.x = data.x;
                    gameState.players.redVanguard.y = data.y;
                    // Paint red territory
                    const gx = Math.floor(data.x);
                    const gy = Math.floor(data.y);
                    const paintOffsets = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
                    for (const [dx, dy] of paintOffsets) {
                        const px = gx + dx;
                        const py = gy + dy;
                        if (px >= 0 && px < GAME_CONFIG.GRID_WIDTH && py >= 0 && py < GAME_CONFIG.GRID_HEIGHT) {
                            gameState.grid[py][px] = GAME_CONFIG.TEAM_ENEMY;
                        }
                    }
                    break;

                case 'skill':
                    // Skills from commanders - HOST spawns directly (no ready check needed)
                    // Commander already verified ready state locally
                    if (senderTeam === 'blue') {
                        if (data.skill === 'hero') {
                            spawnHero(gameState, data.x, data.y);
                        }
                        if (data.skill === 'turret') {
                            spawnTurret(gameState, data.x, data.y);
                        }
                        if (data.skill === 'meteor') {
                            // Blue meteor - damage red units, paint blue
                            applyMeteor(gameState, data.x, data.y, GAME_CONFIG.TEAM_PLAYER, GAME_CONFIG.TEAM_ENEMY);
                        }
                        if (data.skill === 'boss') {
                            if (!gameState.boss.player) spawnBoss(gameState, GAME_CONFIG.TEAM_PLAYER);
                        }
                    } else {
                        // Red team skills
                        if (data.skill === 'hero') {
                            gameState.units.enemy.push(createUnit('hero', GAME_CONFIG.TEAM_ENEMY, data.x, data.y));
                        }
                        if (data.skill === 'turret') {
                            gameState.units.enemy.push(createUnit('turret', GAME_CONFIG.TEAM_ENEMY, data.x, data.y));
                        }
                        if (data.skill === 'meteor') {
                            // Red meteor - damage blue units, paint red
                            applyMeteor(gameState, data.x, data.y, GAME_CONFIG.TEAM_ENEMY, GAME_CONFIG.TEAM_PLAYER);
                        }
                        if (data.skill === 'boss') {
                            if (!gameState.boss.enemy) spawnBoss(gameState, GAME_CONFIG.TEAM_ENEMY);
                        }
                    }
                    break;

                case 'shoot':
                    // Striker shooting
                    if (senderTeam === 'blue') {
                        // Blue striker shoots red units
                        const target = [...gameState.units.enemy, gameState.boss.enemy].find(u => u && u.id === data.targetId);
                        if (target) {
                            target.hp -= data.damage;
                            if (target.hp <= 0) {
                                target.state = 'dead';
                                gameState.stats.playerKills++;
                            }
                        }
                    } else {
                        // Red striker shoots blue units
                        const target = [...gameState.units.player, gameState.boss.player].find(u => u && u.id === data.targetId);
                        if (target) {
                            target.hp -= data.damage;
                            if (target.hp <= 0) {
                                target.state = 'dead';
                                gameState.stats.enemyKills = (gameState.stats.enemyKills || 0) + 1;
                            }
                        }
                    }
                    break;
            }
        }

        // NON-HOST: Handle messages from host
        function handleHostMessage(data) {
            switch(data.type) {
                case 'sync':
                    gameState = data.state;
                    updateWaitingRoom();
                    break;

                case 'delta':
                    // Apply delta updates
                    gameState.timeRemaining = data.t;
                    gameState.stats.playerKills = data.pk;
                    gameState.stats.playerTiles = data.pt;
                    gameState.stats.enemyTiles = data.et;
                    gameState.gameEnded = data.ended;
                    gameState.players.vanguard.x = data.vx;
                    gameState.players.vanguard.y = data.vy;
                    if (data.rvx !== undefined) {
                        gameState.players.redVanguard.x = data.rvx;
                        gameState.players.redVanguard.y = data.rvy;
                    }
                    // Apply grid changes
                    if (data.gc) {
                        data.gc.forEach(([x, y, team]) => {
                            gameState.grid[y][x] = team;
                        });
                    }
                    // Reconstruct units (simplified)
                    if (data.pu) reconstructUnits(data.pu, 'player');
                    if (data.eu) reconstructUnits(data.eu, 'enemy');
                    // Boss
                    if (data.bp) reconstructBoss(data.bp, 'player');
                    if (data.be) reconstructBoss(data.be, 'enemy');
                    // Projectiles
                    if (data.proj) reconstructProjectiles(data.proj);

                    if (gameState.gameEnded) showGameOver();
                    break;

                case 'gameStart':
                    gameState = data.state;
                    gameState.gameStarted = true;
                    document.getElementById('waitingRoom').classList.add('hidden');
                    break;

                case 'gameEnd':
                    gameState.gameEnded = true;
                    gameState.stats = data.stats;
                    showGameOver();
                    break;
            }
        }

        // Helper functions for delta reconstruction
        function reconstructUnits(arr, side) {
            const typeMap = { s: 'soldier', h: 'hero', t: 'turret', b: 'boss' };
            const stateMap = { m: 'moving', f: 'fighting', i: 'idle', d: 'dead' };
            const team = side === 'player' ? GAME_CONFIG.TEAM_PLAYER : GAME_CONFIG.TEAM_ENEMY;

            gameState.units[side] = arr.map(u => ({
                id: u[0],
                type: typeMap[u[1]] || 'soldier',
                x: parseFloat(u[2]),
                y: parseFloat(u[3]),
                hp: u[4],
                state: stateMap[u[5]] || 'moving',
                team: team,
                size: GAME_CONFIG.UNITS[typeMap[u[1]] || 'soldier'].size,
                scanAngle: u[6] ? parseFloat(u[6]) : undefined
            }));
        }

        function reconstructBoss(arr, side) {
            if (!arr) {
                gameState.boss[side] = null;
                return;
            }
            const team = side === 'player' ? GAME_CONFIG.TEAM_PLAYER : GAME_CONFIG.TEAM_ENEMY;
            gameState.boss[side] = {
                id: `boss_${side}`,
                type: 'boss',
                x: parseFloat(arr[0]),
                y: parseFloat(arr[1]),
                hp: arr[2],
                weakPointVisible: arr[3] === 1,
                state: 'moving',
                team: team,
                size: GAME_CONFIG.UNITS.boss.size
            };
        }

        function reconstructProjectiles(arr) {
            gameState.projectiles = arr.map(p => ({
                id: p[0],
                x: parseFloat(p[1]),
                y: parseFloat(p[2]),
                targetX: parseFloat(p[3]),
                targetY: parseFloat(p[4]),
                team: p[5],
                alive: true
            }));
        }

        function updateConnectionUI() {
            const p = gameState.pvpPlayers;
            document.getElementById('blueVanguardDot').className = 'dot ' + (p.blue.vanguard ? 'online' : 'offline');
            document.getElementById('blueStrikerDot').className = 'dot ' + (p.blue.striker ? 'online' : 'offline');
            document.getElementById('blueCommanderDot').className = 'dot ' + (p.blue.commander ? 'online' : 'offline');
            document.getElementById('redVanguardDot').className = 'dot ' + (p.red.vanguard ? 'online' : 'offline');
            document.getElementById('redStrikerDot').className = 'dot ' + (p.red.striker ? 'online' : 'offline');
            document.getElementById('redCommanderDot').className = 'dot ' + (p.red.commander ? 'online' : 'offline');
        }

        // ==================== THREE.JS ====================
        let scene, camera, renderer;
        let currentCameraAngle = 0; // 0=top, 1=2.5D, 2=follow
        let gridMeshes = [];
        let unitMeshes = {};
        let projectileMeshes = {};
        let playerMesh = null;      // Blue vanguard
        let redPlayerMesh = null;   // Red vanguard

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Orthographic camera for top-down view
            const aspect = window.innerWidth / window.innerHeight;
            const viewHeight = GAME_CONFIG.GRID_HEIGHT * GAME_CONFIG.CELL_SIZE / 2 + 5;
            const viewWidth = viewHeight * aspect;

            camera = new THREE.OrthographicCamera(-viewWidth, viewWidth, viewHeight, -viewHeight, 0.1, 1000);
            camera.position.set(0, 50, 0);
            camera.lookAt(0, 0, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Create grid
            createGrid();

            // Create player
            createPlayer();

            // Start animation
            animate();
        }

        function createGrid() {
            for (let y = 0; y < GAME_CONFIG.GRID_HEIGHT; y++) {
                gridMeshes[y] = [];
                for (let x = 0; x < GAME_CONFIG.GRID_WIDTH; x++) {
                    const geo = new THREE.BoxGeometry(GAME_CONFIG.CELL_SIZE - 0.05, 0.1, GAME_CONFIG.CELL_SIZE - 0.05);
                    const mat = new THREE.MeshStandardMaterial({ color: GAME_CONFIG.COLOR_NEUTRAL });
                    const cell = new THREE.Mesh(geo, mat);
                    cell.position.set(
                        (x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE,
                        0,
                        (y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE
                    );
                    gridMeshes[y][x] = cell;
                    scene.add(cell);
                }
            }
        }

        function createPlayer() {
            // Blue Vanguard (always visible)
            const blueGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 8);
            const blueMat = new THREE.MeshStandardMaterial({ color: 0x3498db, emissive: 0x2980b9, emissiveIntensity: 0.3 });
            playerMesh = new THREE.Mesh(blueGeo, blueMat);
            playerMesh.position.y = 0.75;
            scene.add(playerMesh);

            // Red Vanguard (always visible)
            const redGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 8);
            const redMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c, emissive: 0xc0392b, emissiveIntensity: 0.3 });
            redPlayerMesh = new THREE.Mesh(redGeo, redMat);
            redPlayerMesh.position.y = 0.75;
            scene.add(redPlayerMesh);
        }

        // Track last grid state for efficient updates
        let lastRenderedGrid = null;

        function updateGrid() {
            // Initialize tracking array on first call
            if (!lastRenderedGrid) {
                lastRenderedGrid = gameState.grid.map(row => row.map(() => -1));
            }

            // Only update cells that changed
            for (let y = 0; y < GAME_CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < GAME_CONFIG.GRID_WIDTH; x++) {
                    const state = gameState.grid[y][x];
                    if (state !== lastRenderedGrid[y][x]) {
                        const cell = gridMeshes[y][x];
                        if (state === GAME_CONFIG.TEAM_PLAYER) {
                            cell.material.color.setHex(GAME_CONFIG.COLOR_PLAYER);
                        } else if (state === GAME_CONFIG.TEAM_ENEMY) {
                            cell.material.color.setHex(GAME_CONFIG.COLOR_ENEMY);
                        } else {
                            cell.material.color.setHex(GAME_CONFIG.COLOR_NEUTRAL);
                        }
                        lastRenderedGrid[y][x] = state;
                    }
                }
            }
        }

        // Create health bar for units
        function createHealthBar(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 8;
            const ctx = canvas.getContext('2d');

            // Background (dark)
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 64, 8);

            // Health (green)
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(1, 1, 62, 6);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(width, height, 1);
            sprite.name = 'healthBar';
            sprite.userData = { canvas, ctx, texture };

            return sprite;
        }

        // Update health bar display
        function updateHealthBar(sprite, currentHp, maxHp) {
            if (!sprite || !sprite.userData.ctx) return;
            const { ctx, texture } = sprite.userData;
            const ratio = Math.max(0, currentHp / maxHp);

            // Clear and redraw
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 64, 8);

            // Health color: green > yellow > red
            let color = '#2ecc71';
            if (ratio < 0.3) color = '#e74c3c';
            else if (ratio < 0.6) color = '#f39c12';

            ctx.fillStyle = color;
            ctx.fillRect(1, 1, Math.floor(62 * ratio), 6);

            texture.needsUpdate = true;
        }

        // Create fancy mesh for each unit type
        function createUnitMesh(unit) {
            const config = GAME_CONFIG.UNITS[unit.type];
            const isPlayer = unit.team === GAME_CONFIG.TEAM_PLAYER;
            const baseColor = isPlayer ? 0x3498db : 0xe74c3c;
            const group = new THREE.Group();

            if (unit.type === 'soldier') {
                // Soldier: Sphere body + cone head (little minion)
                const bodyGeo = new THREE.SphereGeometry(config.size * 0.5, 8, 6);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    emissive: baseColor,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = config.size * 0.5;
                group.add(body);

                // Eyes (two small white spheres)
                const eyeGeo = new THREE.SphereGeometry(config.size * 0.12, 6, 6);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-config.size * 0.15, config.size * 0.6, config.size * 0.35);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(config.size * 0.15, config.size * 0.6, config.size * 0.35);
                group.add(leftEye, rightEye);

                // Pupil
                const pupilGeo = new THREE.SphereGeometry(config.size * 0.06, 6, 6);
                const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
                leftPupil.position.set(-config.size * 0.15, config.size * 0.6, config.size * 0.42);
                const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
                rightPupil.position.set(config.size * 0.15, config.size * 0.6, config.size * 0.42);
                group.add(leftPupil, rightPupil);

            } else if (unit.type === 'hero') {
                // Hero: Taller capsule body + crown
                const bodyGeo = new THREE.CapsuleGeometry(config.size * 0.35, config.size * 0.6, 6, 12);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xf1c40f, // Gold
                    emissive: 0xf39c12,
                    emissiveIntensity: 0.4,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = config.size * 0.6;
                group.add(body);

                // Crown (3 spikes)
                const crownMat = new THREE.MeshStandardMaterial({ color: 0xf1c40f, metalness: 0.9 });
                for (let i = -1; i <= 1; i++) {
                    const spikeGeo = new THREE.ConeGeometry(config.size * 0.1, config.size * 0.3, 4);
                    const spike = new THREE.Mesh(spikeGeo, crownMat);
                    spike.position.set(i * config.size * 0.2, config.size * 1.1, 0);
                    group.add(spike);
                }

                // Eyes (glowing)
                const eyeGeo = new THREE.SphereGeometry(config.size * 0.1, 6, 6);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-config.size * 0.15, config.size * 0.75, config.size * 0.3);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(config.size * 0.15, config.size * 0.75, config.size * 0.3);
                group.add(leftEye, rightEye);

            } else if (unit.type === 'turret') {
                // Turret: Base + rotating head (top + barrels) - Color based on team
                const turretColor = isPlayer ? 0x3498db : 0xe74c3c; // Blue for player, Red for enemy
                const turretEmissive = isPlayer ? 0x2980b9 : 0xc0392b;
                const baseMat = new THREE.MeshStandardMaterial({
                    color: turretColor,
                    emissive: turretEmissive,
                    emissiveIntensity: 0.3,
                    metalness: 0.6
                });

                // Base (cylinder) - stays fixed
                const baseGeo = new THREE.CylinderGeometry(config.size * 0.5, config.size * 0.6, config.size * 0.4, 8);
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = config.size * 0.2;
                group.add(base);

                // Turret Head group (rotates together) - children[1]
                const turretHead = new THREE.Group();
                turretHead.position.y = config.size * 0.6; // Pivot point at top of base

                // Top (sphere) - part of head
                const topGeo = new THREE.SphereGeometry(config.size * 0.4, 12, 8);
                const top = new THREE.Mesh(topGeo, baseMat);
                turretHead.add(top);

                // Barrels (2 cylinders) - part of head
                const barrelGeo = new THREE.CylinderGeometry(config.size * 0.08, config.size * 0.08, config.size * 0.6, 6);
                const barrelMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, metalness: 0.8 });
                const barrel1 = new THREE.Mesh(barrelGeo, barrelMat);
                barrel1.rotation.x = Math.PI / 2;
                barrel1.position.set(-config.size * 0.15, 0, config.size * 0.5);
                const barrel2 = new THREE.Mesh(barrelGeo, barrelMat);
                barrel2.rotation.x = Math.PI / 2;
                barrel2.position.set(config.size * 0.15, 0, config.size * 0.5);
                turretHead.add(barrel1, barrel2);

                group.add(turretHead);

                // Range indicator ring - also team colored
                const ringGeo = new THREE.RingGeometry(GAME_CONFIG.UNITS.turret.area * GAME_CONFIG.CELL_SIZE - 0.1,
                    GAME_CONFIG.UNITS.turret.area * GAME_CONFIG.CELL_SIZE, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: turretColor,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.05;
                group.add(ring);

                // Rotate turret to face enemy (player turrets face negative Z / low Y)
                group.rotation.y = isPlayer ? Math.PI : 0;

            } else if (unit.type === 'boss') {
                // Boss: Large intimidating creature
                const bossColor = isPlayer ? 0x8e44ad : 0xc0392b;

                // Body (large box with rounded feel)
                const bodyGeo = new THREE.BoxGeometry(config.size, config.size * 1.2, config.size * 0.8);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: bossColor,
                    emissive: bossColor,
                    emissiveIntensity: 0.4
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = config.size * 0.7;
                group.add(body);

                // Head (smaller box on top)
                const headGeo = new THREE.BoxGeometry(config.size * 0.6, config.size * 0.5, config.size * 0.5);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.y = config.size * 1.5;
                group.add(head);

                // Horns
                const hornGeo = new THREE.ConeGeometry(config.size * 0.15, config.size * 0.5, 6);
                const hornMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                leftHorn.position.set(-config.size * 0.25, config.size * 1.9, 0);
                leftHorn.rotation.z = Math.PI * 0.15;
                const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                rightHorn.position.set(config.size * 0.25, config.size * 1.9, 0);
                rightHorn.rotation.z = -Math.PI * 0.15;
                group.add(leftHorn, rightHorn);

                // Glowing eyes
                const eyeGeo = new THREE.SphereGeometry(config.size * 0.12, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: isPlayer ? 0x9b59b6 : 0xe74c3c });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-config.size * 0.15, config.size * 1.55, config.size * 0.25);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(config.size * 0.15, config.size * 1.55, config.size * 0.25);
                group.add(leftEye, rightEye);

                // Arms (2 boxes)
                const armGeo = new THREE.BoxGeometry(config.size * 0.3, config.size * 0.8, config.size * 0.3);
                const leftArm = new THREE.Mesh(armGeo, bodyMat);
                leftArm.position.set(-config.size * 0.65, config.size * 0.6, 0);
                const rightArm = new THREE.Mesh(armGeo, bodyMat);
                rightArm.position.set(config.size * 0.65, config.size * 0.6, 0);
                group.add(leftArm, rightArm);

                // Weak point indicator (only when visible)
                if (unit.weakPointVisible) {
                    const weakGeo = new THREE.SphereGeometry(config.size * 0.2, 16, 16);
                    const weakMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const weakPoint = new THREE.Mesh(weakGeo, weakMat);
                    weakPoint.position.y = config.size * 0.7;
                    weakPoint.name = 'weakPoint';
                    group.add(weakPoint);
                }
            }

            // Add health bar above unit (different heights for different unit types)
            const healthBarHeights = { soldier: 1.8, hero: 3.5, turret: 1.5, boss: 12.0 };
            const healthBarWidths = { soldier: 1.2, hero: 2.0, turret: 2.0, boss: 5.0 };
            const healthBar = createHealthBar(healthBarWidths[unit.type], 0.2);
            healthBar.position.y = healthBarHeights[unit.type];
            group.add(healthBar);

            group.userData = { type: unit.type, team: unit.team, createTime: Date.now(), maxHp: config.hp };
            return group;
        }

        function updateUnitsVisual() {
            const currentTime = Date.now();

            // Clear old meshes
            Object.keys(unitMeshes).forEach(id => {
                const found = [...gameState.units.player, ...gameState.units.enemy, gameState.boss.player, gameState.boss.enemy]
                    .filter(u => u).find(u => u.id === id);
                if (!found) {
                    scene.remove(unitMeshes[id]);
                    delete unitMeshes[id];
                }
            });

            // Create/update unit meshes
            const allUnits = [...gameState.units.player, ...gameState.units.enemy];
            if (gameState.boss.player) allUnits.push(gameState.boss.player);
            if (gameState.boss.enemy) allUnits.push(gameState.boss.enemy);

            allUnits.forEach(unit => {
                if (!unit || unit.state === 'dead') return;

                // Create mesh if needed
                if (!unitMeshes[unit.id]) {
                    const mesh = createUnitMesh(unit);
                    unitMeshes[unit.id] = mesh;
                    scene.add(mesh);
                }

                const mesh = unitMeshes[unit.id];

                // Position
                mesh.position.set(
                    (unit.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE,
                    0,
                    (unit.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE
                );

                // Update health bar
                const healthBar = mesh.getObjectByName('healthBar');
                if (healthBar && mesh.userData.maxHp) {
                    updateHealthBar(healthBar, unit.hp, mesh.userData.maxHp);
                }

                // Animations based on unit type
                const elapsed = (currentTime - mesh.userData.createTime) / 1000;

                if (unit.type === 'soldier') {
                    // Bobbing animation
                    mesh.children[0].position.y = GAME_CONFIG.UNITS.soldier.size * 0.5 + Math.sin(elapsed * 5) * 0.1;
                    // Look toward movement direction (player faces low Y = Math.PI, enemy faces high Y = 0)
                    if (unit.state === 'moving') {
                        mesh.rotation.y = unit.team === GAME_CONFIG.TEAM_PLAYER ? Math.PI : 0;
                    }
                } else if (unit.type === 'hero') {
                    // Gentle floating + rotation (base toward enemy)
                    mesh.children[0].position.y = GAME_CONFIG.UNITS.hero.size * 0.6 + Math.sin(elapsed * 3) * 0.15;
                    const baseRot = unit.team === GAME_CONFIG.TEAM_PLAYER ? Math.PI : 0;
                    mesh.rotation.y = baseRot + Math.sin(elapsed * 2) * 0.1;
                } else if (unit.type === 'turret') {
                    // Rotate turret top using actual scanAngle from game state
                    if (mesh.children[1]) {
                        const scanAngle = unit.scanAngle !== undefined ? unit.scanAngle : 0;
                        mesh.children[1].rotation.y = scanAngle;
                    }
                    // Pulse range ring
                    if (mesh.children[5]) {
                        mesh.children[5].material.opacity = 0.15 + Math.sin(elapsed * 3) * 0.1;
                    }
                } else if (unit.type === 'boss') {
                    // Intimidating sway
                    mesh.rotation.y = Math.sin(elapsed) * 0.05;
                    // Arms swing
                    if (mesh.children[5]) mesh.children[5].rotation.x = Math.sin(elapsed * 2) * 0.2;
                    if (mesh.children[6]) mesh.children[6].rotation.x = -Math.sin(elapsed * 2) * 0.2;

                    // Update weak point visibility
                    const weakPoint = mesh.getObjectByName('weakPoint');
                    if (unit.weakPointVisible && !weakPoint) {
                        const weakGeo = new THREE.SphereGeometry(GAME_CONFIG.UNITS.boss.size * 0.2, 16, 16);
                        const weakMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                        const weak = new THREE.Mesh(weakGeo, weakMat);
                        weak.position.y = GAME_CONFIG.UNITS.boss.size * 0.7;
                        weak.name = 'weakPoint';
                        mesh.add(weak);
                    } else if (!unit.weakPointVisible && weakPoint) {
                        mesh.remove(weakPoint);
                    }
                    if (weakPoint) {
                        weakPoint.scale.setScalar(1 + Math.sin(elapsed * 8) * 0.2);
                    }
                }

                // Fighting animation - shake
                if (unit.state === 'fighting') {
                    mesh.position.x += Math.sin(elapsed * 30) * 0.05;
                }
            });
        }

        function updateProjectilesVisual() {
            // Remove old projectiles
            Object.keys(projectileMeshes).forEach(id => {
                const found = gameState.projectiles && gameState.projectiles.find(p => p.id === id);
                if (!found) {
                    scene.remove(projectileMeshes[id]);
                    delete projectileMeshes[id];
                }
            });

            // Create/update projectile meshes
            if (!gameState.projectiles) return;

            gameState.projectiles.forEach(proj => {
                if (!proj.alive) return;

                // Create mesh if needed
                if (!projectileMeshes[proj.id]) {
                    const isPlayer = proj.team === GAME_CONFIG.TEAM_PLAYER;
                    const color = isPlayer ? 0x1abc9c : 0xe74c3c;

                    const group = new THREE.Group();

                    // Glowing projectile ball
                    const ballGeo = new THREE.SphereGeometry(0.4, 8, 8);
                    const ballMat = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.9
                    });
                    const ball = new THREE.Mesh(ballGeo, ballMat);
                    group.add(ball);

                    // Glow effect
                    const glowGeo = new THREE.SphereGeometry(0.6, 8, 8);
                    const glowMat = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    group.add(glow);

                    // Trail
                    const trailGeo = new THREE.CylinderGeometry(0.15, 0.05, 1.5, 6);
                    const trailMat = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.5
                    });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    trail.rotation.x = Math.PI / 2;
                    trail.position.z = -0.8;
                    group.add(trail);

                    projectileMeshes[proj.id] = group;
                    scene.add(group);
                }

                const mesh = projectileMeshes[proj.id];

                // Position
                mesh.position.set(
                    (proj.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE,
                    1.5, // Elevated above ground
                    (proj.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE
                );

                // Rotate toward target
                const dx = proj.targetX - proj.x;
                const dy = proj.targetY - proj.y;
                mesh.rotation.y = Math.atan2(dx, dy);

                // Pulsing glow effect
                const t = Date.now() * 0.01;
                mesh.children[1].scale.setScalar(1 + Math.sin(t) * 0.2);
            });
        }

        function updatePlayerVisual() {
            // Blue vanguard position
            const bx = (gameState.players.vanguard.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
            const bz = (gameState.players.vanguard.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
            playerMesh.position.x = bx;
            playerMesh.position.z = bz;

            // Red vanguard position
            if (gameState.players.redVanguard) {
                const rx = (gameState.players.redVanguard.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
                const rz = (gameState.players.redVanguard.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
                redPlayerMesh.position.x = rx;
                redPlayerMesh.position.z = rz;
            }

            // Follow MY vanguard with camera
            const myVanguard = MY_TEAM === 'blue' ? gameState.players.vanguard : gameState.players.redVanguard;
            const px = (myVanguard.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
            const pz = (myVanguard.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;

            // Camera behavior based on mode
            if (currentCameraAngle === 0) {
                // Top-down: slight follow
                camera.position.x = px * 0.3;
                camera.position.z = pz * 0.3;
            } else if (currentCameraAngle === 1) {
                // 2.5D: isometric follow
                camera.position.x = px * 0.5;
                camera.position.z = pz * 0.5 + 25;
            } else if (currentCameraAngle === 2) {
                // Follow: chase camera behind player
                camera.position.x = px;
                camera.position.z = pz + 20;
                camera.lookAt(px, 0, pz - 10);
            }
        }

        function setCameraAngle(angle) {
            currentCameraAngle = angle;

            // Update button states
            document.querySelectorAll('.cam-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === angle);
            });

            const aspect = window.innerWidth / window.innerHeight;
            const viewHeight = GAME_CONFIG.GRID_HEIGHT * GAME_CONFIG.CELL_SIZE / 2 + 5;
            const viewWidth = viewHeight * aspect;

            if (angle === 0) {
                // Top-down view
                camera.position.set(0, 50, 0);
                camera.up.set(0, 0, -1);
                camera.lookAt(0, 0, 0);
            } else if (angle === 1) {
                // 2.5D isometric view
                camera.position.set(0, 40, 30);
                camera.up.set(0, 1, 0);
                camera.lookAt(0, 0, 0);
            } else if (angle === 2) {
                // Follow view (behind player)
                const px = (gameState.players.vanguard.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
                const pz = (gameState.players.vanguard.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE;
                camera.position.set(px, 25, pz + 20);
                camera.up.set(0, 1, 0);
                camera.lookAt(px, 0, pz - 10);
            }

            camera.updateProjectionMatrix();
        }

        // ==================== INPUT ====================
        const keys = {};
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);

        function handleInput(deltaTime) {
            const speed = 5 * deltaTime;
            let moved = false;

            // Which vanguard do I control?
            const myVanguard = MY_TEAM === 'blue' ? gameState.players.vanguard : gameState.players.redVanguard;
            const myTeamCode = MY_TEAM === 'blue' ? GAME_CONFIG.TEAM_PLAYER : GAME_CONFIG.TEAM_ENEMY;

            // Movement (red vanguard moves opposite direction visually since they start at top)
            if (MY_TEAM === 'blue') {
                if (keys['KeyW'] || keys['ArrowUp']) { myVanguard.y -= speed; moved = true; }
                if (keys['KeyS'] || keys['ArrowDown']) { myVanguard.y += speed; moved = true; }
            } else {
                // Red vanguard: W goes towards enemy (increasing Y)
                if (keys['KeyW'] || keys['ArrowUp']) { myVanguard.y += speed; moved = true; }
                if (keys['KeyS'] || keys['ArrowDown']) { myVanguard.y -= speed; moved = true; }
            }
            if (keys['KeyA'] || keys['ArrowLeft']) { myVanguard.x -= speed; moved = true; }
            if (keys['KeyD'] || keys['ArrowRight']) { myVanguard.x += speed; moved = true; }

            // Clamp
            myVanguard.x = Math.max(0, Math.min(GAME_CONFIG.GRID_WIDTH - 1, myVanguard.x));
            myVanguard.y = Math.max(0, Math.min(GAME_CONFIG.GRID_HEIGHT - 1, myVanguard.y));

            // Paint trail (Permanent Rage) - 5 tiles: center + cross pattern
            if (moved) {
                const gx = Math.floor(myVanguard.x);
                const gy = Math.floor(myVanguard.y);

                const paintOffsets = [[0, 0], [-1, 0], [1, 0], [0, -1], [0, 1]];

                if (IS_HOST) {
                    // Host paints directly
                    for (const [dx, dy] of paintOffsets) {
                        const px = gx + dx;
                        const py = gy + dy;
                        if (px >= 0 && px < GAME_CONFIG.GRID_WIDTH && py >= 0 && py < GAME_CONFIG.GRID_HEIGHT) {
                            gameState.grid[py][px] = myTeamCode;
                        }
                    }
                } else {
                    // Non-host (red vanguard): send movement to host
                    sendToHost({
                        type: 'redVanguardMove',
                        x: myVanguard.x,
                        y: myVanguard.y
                    });
                }
            }
        }

        // ==================== UI ====================
        function updateUI() {
            // Timer
            const minutes = Math.floor(gameState.timeRemaining / 60);
            const seconds = Math.floor(gameState.timeRemaining % 60);
            const timerEl = document.getElementById('timer');
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            timerEl.className = gameState.timeRemaining < 60 ? 'warning' : '';

            // Stats
            document.getElementById('killCount').textContent = gameState.stats.playerKills;
            document.getElementById('tileCount').textContent = gameState.stats.playerTiles;

            // Territory bar
            const total = GAME_CONFIG.GRID_WIDTH * GAME_CONFIG.GRID_HEIGHT;
            const playerPct = Math.round(gameState.stats.playerTiles / total * 100);
            const enemyPct = Math.round(gameState.stats.enemyTiles / total * 100);
            document.getElementById('playerTerritory').style.width = playerPct + '%';
            document.getElementById('playerTerritory').textContent = playerPct + '%';
            document.getElementById('enemyTerritory').style.width = enemyPct + '%';
            document.getElementById('enemyTerritory').textContent = enemyPct + '%';
        }

        function showGameOver() {
            const total = GAME_CONFIG.GRID_WIDTH * GAME_CONFIG.GRID_HEIGHT;
            // Check winner based on MY_TEAM
            const myTiles = MY_TEAM === 'blue' ? gameState.stats.playerTiles : gameState.stats.enemyTiles;
            const enemyTiles = MY_TEAM === 'blue' ? gameState.stats.enemyTiles : gameState.stats.playerTiles;
            const myKills = MY_TEAM === 'blue' ? gameState.stats.playerKills : (gameState.stats.enemyKills || 0);
            const myPct = Math.round(myTiles / total * 100);
            const won = myTiles > enemyTiles;

            document.getElementById('resultTitle').textContent = won ? 'VICTORY!' : 'DEFEAT';
            document.getElementById('resultTitle').style.color = won ? '#2ecc71' : '#e74c3c';
            document.getElementById('resultText').textContent = `Your team controls ${myPct}% of the field!`;
            document.getElementById('resultStats').textContent = `Tiles painted: ${myTiles} | Team kills: ${myKills}`;
            document.getElementById('gameOver').classList.remove('hidden');
        }

        // ==================== GAME LOOP ====================
        let lastTime = 0;
        let spawnTimer = 0;
        let syncTimer = 0;
        const SYNC_INTERVAL = 0.1; // 100ms = 10 syncs per second (optimized)

        // Delta sync tracking
        let lastGridState = null;
        let lastSyncTime = 0;
        let fullSyncCounter = 0;

        function createDeltaSync() {
            const delta = {
                type: 'delta',
                t: gameState.timeRemaining,
                pk: gameState.stats.playerKills,
                pt: gameState.stats.playerTiles,
                et: gameState.stats.enemyTiles,
                ended: gameState.gameEnded,
                vx: gameState.players.vanguard.x,
                vy: gameState.players.vanguard.y,
                rvx: gameState.players.redVanguard ? gameState.players.redVanguard.x : 0,
                rvy: gameState.players.redVanguard ? gameState.players.redVanguard.y : 0
            };

            // Grid changes (only changed tiles)
            const gridChanges = [];
            for (let y = 0; y < GAME_CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < GAME_CONFIG.GRID_WIDTH; x++) {
                    const current = gameState.grid[y][x];
                    const last = lastGridState ? lastGridState[y][x] : -1;
                    if (current !== last) {
                        gridChanges.push([x, y, current]); // [x, y, team]
                    }
                }
            }
            if (gridChanges.length > 0) {
                delta.gc = gridChanges;
            }

            // Units (compact format: id, type, x, y, hp, state, scanAngle for turrets)
            delta.pu = gameState.units.player.map(u => {
                const arr = [u.id, u.type[0], u.x.toFixed(1), u.y.toFixed(1), u.hp, u.state[0]];
                if (u.type === 'turret' && u.scanAngle !== undefined) arr.push(u.scanAngle.toFixed(2));
                return arr;
            });
            delta.eu = gameState.units.enemy.map(u => {
                const arr = [u.id, u.type[0], u.x.toFixed(1), u.y.toFixed(1), u.hp, u.state[0]];
                if (u.type === 'turret' && u.scanAngle !== undefined) arr.push(u.scanAngle.toFixed(2));
                return arr;
            });

            // Boss (if exists)
            if (gameState.boss.player) {
                const b = gameState.boss.player;
                delta.bp = [b.x.toFixed(1), b.y.toFixed(1), b.hp, b.weakPointVisible ? 1 : 0];
            }
            if (gameState.boss.enemy) {
                const b = gameState.boss.enemy;
                delta.be = [b.x.toFixed(1), b.y.toFixed(1), b.hp, b.weakPointVisible ? 1 : 0];
            }

            // Projectiles (compact format: id, x, y, targetX, targetY, team)
            if (gameState.projectiles && gameState.projectiles.length > 0) {
                delta.proj = gameState.projectiles.map(p => [
                    p.id, p.x.toFixed(1), p.y.toFixed(1), p.targetX.toFixed(1), p.targetY.toFixed(1), p.team
                ]);
            }

            // Update last grid state
            lastGridState = gameState.grid.map(row => [...row]);

            return delta;
        }

        function createFullSync() {
            return { type: 'sync', state: gameState };
        }

        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Only run game logic after game starts
            if (gameState.gameStarted && !gameState.gameEnded) {
                // Input (both host and client handle their own input)
                handleInput(deltaTime);

                if (IS_HOST) {
                    // HOST: Run full game logic
                    updateGame(gameState, deltaTime);

                    // Spawns
                    spawnTimer += deltaTime;
                    if (spawnTimer >= GAME_CONFIG.MINION_SPAWN_INTERVAL) {
                        spawnTimer = 0;
                        spawnPlayerMinions(gameState);
                        spawnEnemyMinions(gameState);
                    }

                    // AI logic (minions still use AI, but not vanguards)
                    updateAI(gameState, deltaTime);

                    // Broadcast state
                    syncTimer += deltaTime;
                    if (syncTimer >= SYNC_INTERVAL) {
                        syncTimer = 0;
                        fullSyncCounter++;

                        if (fullSyncCounter >= 30) {
                            fullSyncCounter = 0;
                            broadcast(createFullSync());
                        } else {
                            broadcast(createDeltaSync());
                        }
                    }
                }

                // Update visuals (both host and client)
                updateGrid();
                updateUnitsVisual();
                updateProjectilesVisual();
                updatePlayerVisual();
                updateUI();

            } else if (gameState.gameEnded) {
                if (IS_HOST && !gameEndBroadcasted) {
                    gameEndBroadcasted = true;
                    broadcast(createDeltaSync());
                    broadcast({ type: 'gameEnd', stats: gameState.stats });
                }
                showGameOver();
            }

            renderer.render(scene, camera);
        }

        let gameEndBroadcasted = false;

        // ==================== RESIZE ====================
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            const viewHeight = GAME_CONFIG.GRID_HEIGHT * GAME_CONFIG.CELL_SIZE / 2 + 5;
            const viewWidth = viewHeight * aspect;
            camera.left = -viewWidth;
            camera.right = viewWidth;
            camera.top = viewHeight;
            camera.bottom = -viewHeight;
            camera.updateProjectionMatrix();
        });

        // ==================== MOBILE CHECK ====================
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
                || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
        }

        // ==================== INIT ====================
        if (isMobile()) {
            document.getElementById('mobileBlock').classList.remove('hidden');
        } else {
            initThreeJS();
            initNetworking();
            updateConnectionUI();
        }
    </script>
</body>
</html>
