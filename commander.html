<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fortal Battle Ground - Commander</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #0a0a1a;
            font-family: 'Segoe UI', sans-serif;
        }
        #gameCanvas { display: block; }

        /* HUD */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            color: white;
            z-index: 100;
        }
        .hud-section { display: flex; gap: 15px; align-items: center; }
        .role-badge {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            background: #e67e22;
            font-size: 1.1em;
        }
        .stat-box {
            background: rgba(255,255,255,0.1);
            padding: 8px 15px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-label { font-size: 0.7em; color: #888; text-transform: uppercase; }
        .stat-value { font-size: 1.3em; font-weight: bold; }

        #timer {
            font-size: 2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        #timer.warning { color: #e74c3c; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* Skills Panel */
        #skillsPanel {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        .skill-btn {
            width: 100px;
            height: 100px;
            border: 3px solid #444;
            border-radius: 15px;
            background: rgba(0,0,0,0.8);
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        .skill-btn:hover:not(.disabled):not(.locked) {
            border-color: #e67e22;
            transform: scale(1.05);
        }
        .skill-btn.active {
            border-color: #e67e22;
            box-shadow: 0 0 20px rgba(230, 126, 34, 0.5);
        }
        .skill-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skill-btn.locked {
            border-color: #666;
            cursor: not-allowed;
        }
        .skill-btn .icon { font-size: 2em; margin-bottom: 5px; }
        .skill-btn .name { font-size: 0.75em; font-weight: bold; }
        .skill-btn .cooldown {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
        }
        .skill-btn .cooldown.hidden { display: none; }
        .skill-btn .hotkey {
            position: absolute;
            top: 5px;
            left: 5px;
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
        }

        /* Ultimate Gauge */
        #ultimateGauge {
            position: fixed;
            bottom: 170px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            z-index: 100;
        }
        #ultimateGauge .label {
            text-align: center;
            color: #888;
            font-size: 0.8em;
            margin-bottom: 5px;
        }
        #ultimateGauge .bar {
            height: 15px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #444;
        }
        #ultimateGauge .fill {
            height: 100%;
            background: linear-gradient(to right, #8e44ad, #e74c3c, #f39c12);
            transition: width 0.3s;
        }
        #ultimateGauge .percent {
            text-align: center;
            color: white;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Territory bar */
        #territoryBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            display: flex;
            z-index: 100;
        }
        #playerTerritory {
            background: linear-gradient(to right, #3498db, #2980b9);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-weight: bold;
        }
        #enemyTerritory {
            background: linear-gradient(to left, #e74c3c, #c0392b);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            padding-left: 10px;
            color: white;
            font-weight: bold;
        }

        /* Instructions */
        #instructions {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 0.85em;
            z-index: 100;
            max-width: 250px;
        }
        #instructions h3 { color: #e67e22; margin-bottom: 10px; }
        kbd { background: #333; padding: 2px 8px; border-radius: 4px; font-family: monospace; }

        /* Selected skill indicator */
        #selectedSkill {
            position: fixed;
            bottom: 220px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(230, 126, 34, 0.9);
            padding: 10px 30px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            z-index: 100;
        }
        #selectedSkill.hidden { display: none; }

        /* Game Over */
        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }
        #gameOver.hidden { display: none; }
        #gameOver h1 { font-size: 4em; margin-bottom: 20px; }
        #gameOver .result { font-size: 2em; margin-bottom: 30px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-section">
            <div class="role-badge">Commander</div>
            <div class="stat-box">
                <div class="stat-label">Room</div>
                <div class="stat-value" id="roomDisplay">---</div>
            </div>
        </div>
        <div id="timer">5:00</div>
        <div class="hud-section">
            <div class="stat-box">
                <div class="stat-label">Kills</div>
                <div class="stat-value" id="killCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Units</div>
                <div class="stat-value" id="unitCount">0</div>
            </div>
        </div>
    </div>

    <!-- Instructions -->
    <div id="instructions">
        <h3>COMMANDER - The Architect</h3>
        <p><kbd>1</kbd> Hero Summon</p>
        <p><kbd>2</kbd> Turret Drop</p>
        <p><kbd>3</kbd> Meteor Shower</p>
        <p><kbd>4</kbd> Summon Boss</p>
        <p style="margin-top:10px;">Click on map to deploy</p>
    </div>

    <!-- Ultimate Gauge -->
    <div id="ultimateGauge">
        <div class="label">ULTIMATE GAUGE</div>
        <div class="bar"><div class="fill" id="ultimateFill" style="width:0%"></div></div>
        <div class="percent" id="ultimatePercent">0%</div>
    </div>

    <!-- Selected Skill Indicator -->
    <div id="selectedSkill" class="hidden">Select target location</div>

    <!-- Skills Panel -->
    <div id="skillsPanel">
        <div class="skill-btn" data-skill="hero" onclick="selectSkill('hero')">
            <span class="hotkey">1</span>
            <span class="icon">‚öîÔ∏è</span>
            <span class="name">Hero</span>
            <div class="cooldown hidden" id="heroCd"></div>
        </div>
        <div class="skill-btn" data-skill="turret" onclick="selectSkill('turret')">
            <span class="hotkey">2</span>
            <span class="icon">üóº</span>
            <span class="name">Turret</span>
            <div class="cooldown hidden" id="turretCd"></div>
        </div>
        <div class="skill-btn" data-skill="meteor" onclick="selectSkill('meteor')">
            <span class="hotkey">3</span>
            <span class="icon">‚òÑÔ∏è</span>
            <span class="name">Meteor</span>
            <div class="cooldown hidden" id="meteorCd"></div>
        </div>
        <div class="skill-btn locked" data-skill="boss" onclick="selectSkill('boss')">
            <span class="hotkey">4</span>
            <span class="icon">üëπ</span>
            <span class="name">Boss</span>
            <div class="cooldown hidden" id="bossCd">üîí</div>
        </div>
    </div>

    <!-- Territory Bar -->
    <div id="territoryBar">
        <div id="playerTerritory" style="width:50%;">50%</div>
        <div id="enemyTerritory" style="width:50%;">50%</div>
    </div>

    <!-- Game Over -->
    <div id="gameOver" class="hidden">
        <h1 id="resultTitle">VICTORY!</h1>
        <div class="result" id="resultText">Your team wins!</div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Game Core -->
    <script src="js/gameCore.js"></script>

    <script>
        // ==================== CONFIG ====================
        const params = new URLSearchParams(window.location.search);
        const ROOM_ID = params.get('room') || 'default-room';
        const MY_ROLE = 'commander';

        // ==================== GAME STATE ====================
        let gameState = createGameState();
        initGrid(gameState);
        gameState.players.commander.connected = true;
        gameState.gameStarted = true;

        let selectedSkill = null;
        let isConnectedToHost = false;

        // ==================== NETWORKING ====================
        let peer = null;
        let connections = {};

        function initNetworking() {
            // Prefix with 'fbg-' to ensure valid peer ID
            const peerId = `fbg-${ROOM_ID}-${MY_ROLE}`;
            peer = new Peer(peerId);

            peer.on('open', (id) => {
                console.log('Connected as:', id);
                document.getElementById('roomDisplay').textContent = ROOM_ID;
                updateConnectionStatus('Connecting to host...');

                // Connect to vanguard (host)
                const hostConn = peer.connect(`fbg-${ROOM_ID}-vanguard`);
                if (hostConn) handleConnection(hostConn);
            });

            peer.on('connection', (conn) => handleConnection(conn));

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                if (err.type === 'peer-unavailable') {
                    updateConnectionStatus('Host not found! Make sure Vanguard opens first.');
                } else {
                    updateConnectionStatus('Connection error: ' + err.type);
                }
            });
        }

        function updateConnectionStatus(msg) {
            let statusEl = document.getElementById('connectionStatus');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'connectionStatus';
                statusEl.style.cssText = 'position:fixed;top:70px;left:20px;background:rgba(0,0,0,0.8);padding:10px 15px;border-radius:10px;color:white;font-size:0.85em;z-index:100;';
                document.body.appendChild(statusEl);
            }
            statusEl.textContent = msg;
            statusEl.style.background = isConnectedToHost ? 'rgba(39,174,96,0.8)' : 'rgba(0,0,0,0.8)';
        }

        function handleConnection(conn) {
            const role = conn.peer.split('-').pop();
            connections[role] = conn;

            conn.on('open', () => {
                gameState.players[role].connected = true;
                if (role === 'vanguard') {
                    updateConnectionStatus('Connected to Host!');
                }
            });

            conn.on('close', () => {
                if (role === 'vanguard') {
                    isConnectedToHost = false;
                    updateConnectionStatus('Disconnected from host');
                }
            });

            conn.on('data', (data) => {
                if (data.type === 'sync') {
                    // Keep our skills state (local cooldowns)
                    const mySkills = gameState.players.commander.skills;

                    // Deep copy important arrays
                    gameState.grid = JSON.parse(JSON.stringify(data.state.grid));
                    gameState.units = JSON.parse(JSON.stringify(data.state.units));
                    gameState.boss = JSON.parse(JSON.stringify(data.state.boss));
                    gameState.stats = data.state.stats;
                    gameState.timeRemaining = data.state.timeRemaining;
                    gameState.gameEnded = data.state.gameEnded;
                    gameState.players = data.state.players;

                    // Restore local skills
                    gameState.players.commander.skills = mySkills;
                    gameState.players.commander.connected = true;
                    isConnectedToHost = true;
                }
            });
        }

        function broadcast(data) {
            Object.values(connections).forEach(conn => {
                if (conn.open) conn.send(data);
            });
        }

        // ==================== THREE.JS ====================
        let scene, camera, renderer, raycaster, mouse;
        let gridMeshes = [];
        let unitMeshes = {};
        let targetMarker = null;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Orthographic camera (top-down with slight angle)
            const aspect = window.innerWidth / window.innerHeight;
            const viewHeight = GAME_CONFIG.GRID_HEIGHT * GAME_CONFIG.CELL_SIZE / 2 + 5;
            const viewWidth = viewHeight * aspect;

            camera = new THREE.OrthographicCamera(-viewWidth, viewWidth, viewHeight, -viewHeight, 0.1, 1000);
            camera.position.set(0, 50, 10);
            camera.lookAt(0, 0, 0);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight.position.set(10, 30, 10);
            scene.add(dirLight);

            // Create grid
            createGrid();

            // Create target marker
            const markerGeo = new THREE.RingGeometry(0.8, 1, 32);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xe67e22, side: THREE.DoubleSide });
            targetMarker = new THREE.Mesh(markerGeo, markerMat);
            targetMarker.rotation.x = -Math.PI / 2;
            targetMarker.position.y = 0.2;
            targetMarker.visible = false;
            scene.add(targetMarker);

            animate();
        }

        function createGrid() {
            for (let y = 0; y < GAME_CONFIG.GRID_HEIGHT; y++) {
                gridMeshes[y] = [];
                for (let x = 0; x < GAME_CONFIG.GRID_WIDTH; x++) {
                    const geo = new THREE.BoxGeometry(GAME_CONFIG.CELL_SIZE - 0.05, 0.1, GAME_CONFIG.CELL_SIZE - 0.05);
                    const mat = new THREE.MeshStandardMaterial({ color: GAME_CONFIG.COLOR_NEUTRAL });
                    const cell = new THREE.Mesh(geo, mat);
                    cell.position.set(
                        (x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE,
                        0,
                        (y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE
                    );
                    cell.userData = { gridX: x, gridY: y };
                    gridMeshes[y][x] = cell;
                    scene.add(cell);
                }
            }
        }

        function updateGrid() {
            for (let y = 0; y < GAME_CONFIG.GRID_HEIGHT; y++) {
                for (let x = 0; x < GAME_CONFIG.GRID_WIDTH; x++) {
                    const cell = gridMeshes[y][x];
                    const state = gameState.grid[y][x];
                    if (state === GAME_CONFIG.TEAM_PLAYER) {
                        cell.material.color.setHex(GAME_CONFIG.COLOR_PLAYER);
                    } else if (state === GAME_CONFIG.TEAM_ENEMY) {
                        cell.material.color.setHex(GAME_CONFIG.COLOR_ENEMY);
                    } else {
                        cell.material.color.setHex(GAME_CONFIG.COLOR_NEUTRAL);
                    }
                }
            }
        }

        // Create fancy mesh for each unit type
        function createUnitMesh(unit) {
            const config = GAME_CONFIG.UNITS[unit.type];
            const isPlayer = unit.team === GAME_CONFIG.TEAM_PLAYER;
            const baseColor = isPlayer ? 0x3498db : 0xe74c3c;
            const group = new THREE.Group();

            if (unit.type === 'soldier') {
                // Soldier: Sphere body + eyes (little minion)
                const bodyGeo = new THREE.SphereGeometry(config.size * 0.5, 8, 6);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: baseColor,
                    emissive: baseColor,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = config.size * 0.5;
                group.add(body);

                // Eyes
                const eyeGeo = new THREE.SphereGeometry(config.size * 0.12, 6, 6);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-config.size * 0.15, config.size * 0.6, config.size * 0.35);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(config.size * 0.15, config.size * 0.6, config.size * 0.35);
                group.add(leftEye, rightEye);

            } else if (unit.type === 'hero') {
                // Hero: Capsule body + crown
                const bodyGeo = new THREE.CapsuleGeometry(config.size * 0.35, config.size * 0.6, 6, 12);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xf1c40f,
                    emissive: 0xf39c12,
                    emissiveIntensity: 0.4,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = config.size * 0.6;
                group.add(body);

                // Crown spikes
                const crownMat = new THREE.MeshStandardMaterial({ color: 0xf1c40f, metalness: 0.9 });
                for (let i = -1; i <= 1; i++) {
                    const spikeGeo = new THREE.ConeGeometry(config.size * 0.1, config.size * 0.3, 4);
                    const spike = new THREE.Mesh(spikeGeo, crownMat);
                    spike.position.set(i * config.size * 0.2, config.size * 1.1, 0);
                    group.add(spike);
                }

            } else if (unit.type === 'turret') {
                // Turret: Base + dome + barrels
                const baseMat = new THREE.MeshStandardMaterial({
                    color: 0x1abc9c,
                    emissive: 0x16a085,
                    emissiveIntensity: 0.3,
                    metalness: 0.6
                });

                const baseGeo = new THREE.CylinderGeometry(config.size * 0.5, config.size * 0.6, config.size * 0.4, 8);
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = config.size * 0.2;
                group.add(base);

                const topGeo = new THREE.SphereGeometry(config.size * 0.4, 12, 8);
                const top = new THREE.Mesh(topGeo, baseMat);
                top.position.y = config.size * 0.6;
                group.add(top);

                const barrelGeo = new THREE.CylinderGeometry(config.size * 0.08, config.size * 0.08, config.size * 0.6, 6);
                const barrelMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50, metalness: 0.8 });
                const barrel1 = new THREE.Mesh(barrelGeo, barrelMat);
                barrel1.rotation.x = Math.PI / 2;
                barrel1.position.set(-config.size * 0.15, config.size * 0.6, config.size * 0.5);
                const barrel2 = new THREE.Mesh(barrelGeo, barrelMat);
                barrel2.rotation.x = Math.PI / 2;
                barrel2.position.set(config.size * 0.15, config.size * 0.6, config.size * 0.5);
                group.add(barrel1, barrel2);

                // Range ring
                const ringGeo = new THREE.RingGeometry(GAME_CONFIG.UNITS.turret.area * GAME_CONFIG.CELL_SIZE - 0.1,
                    GAME_CONFIG.UNITS.turret.area * GAME_CONFIG.CELL_SIZE, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0x1abc9c,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.05;
                group.add(ring);

            } else if (unit.type === 'boss') {
                // Boss: Large intimidating creature
                const bossColor = isPlayer ? 0x8e44ad : 0xc0392b;
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: bossColor,
                    emissive: bossColor,
                    emissiveIntensity: 0.4
                });

                const bodyGeo = new THREE.BoxGeometry(config.size, config.size * 1.2, config.size * 0.8);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = config.size * 0.7;
                group.add(body);

                const headGeo = new THREE.BoxGeometry(config.size * 0.6, config.size * 0.5, config.size * 0.5);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.y = config.size * 1.5;
                group.add(head);

                // Horns
                const hornGeo = new THREE.ConeGeometry(config.size * 0.15, config.size * 0.5, 6);
                const hornMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                leftHorn.position.set(-config.size * 0.25, config.size * 1.9, 0);
                leftHorn.rotation.z = Math.PI * 0.15;
                const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                rightHorn.position.set(config.size * 0.25, config.size * 1.9, 0);
                rightHorn.rotation.z = -Math.PI * 0.15;
                group.add(leftHorn, rightHorn);

                // Glowing eyes
                const eyeGeo = new THREE.SphereGeometry(config.size * 0.12, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: isPlayer ? 0x9b59b6 : 0xe74c3c });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-config.size * 0.15, config.size * 1.55, config.size * 0.25);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(config.size * 0.15, config.size * 1.55, config.size * 0.25);
                group.add(leftEye, rightEye);

                // Arms
                const armGeo = new THREE.BoxGeometry(config.size * 0.3, config.size * 0.8, config.size * 0.3);
                const leftArm = new THREE.Mesh(armGeo, bodyMat);
                leftArm.position.set(-config.size * 0.65, config.size * 0.6, 0);
                const rightArm = new THREE.Mesh(armGeo, bodyMat);
                rightArm.position.set(config.size * 0.65, config.size * 0.6, 0);
                group.add(leftArm, rightArm);
            }

            group.userData = { type: unit.type, team: unit.team, createTime: Date.now() };
            return group;
        }

        function updateUnitsVisual() {
            const currentTime = Date.now();

            Object.keys(unitMeshes).forEach(id => {
                const found = [...gameState.units.player, ...gameState.units.enemy, gameState.boss.player, gameState.boss.enemy]
                    .filter(u => u).find(u => u.id === id);
                if (!found) {
                    scene.remove(unitMeshes[id]);
                    delete unitMeshes[id];
                }
            });

            const allUnits = [...gameState.units.player, ...gameState.units.enemy];
            if (gameState.boss.player) allUnits.push(gameState.boss.player);
            if (gameState.boss.enemy) allUnits.push(gameState.boss.enemy);

            allUnits.forEach(unit => {
                if (!unit || unit.state === 'dead') return;

                if (!unitMeshes[unit.id]) {
                    const mesh = createUnitMesh(unit);
                    unitMeshes[unit.id] = mesh;
                    scene.add(mesh);
                }

                const mesh = unitMeshes[unit.id];
                mesh.position.set(
                    (unit.x - GAME_CONFIG.GRID_WIDTH / 2 + 0.5) * GAME_CONFIG.CELL_SIZE,
                    0,
                    (unit.y - GAME_CONFIG.GRID_HEIGHT / 2 + 0.5) * GAME_CONFIG.CELL_SIZE
                );

                // Animations
                const elapsed = (currentTime - mesh.userData.createTime) / 1000;

                if (unit.type === 'soldier') {
                    mesh.children[0].position.y = GAME_CONFIG.UNITS.soldier.size * 0.5 + Math.sin(elapsed * 5) * 0.1;
                } else if (unit.type === 'hero') {
                    mesh.children[0].position.y = GAME_CONFIG.UNITS.hero.size * 0.6 + Math.sin(elapsed * 3) * 0.15;
                } else if (unit.type === 'turret') {
                    if (mesh.children[1]) mesh.children[1].rotation.y = elapsed * 2;
                    if (mesh.children[5]) mesh.children[5].material.opacity = 0.15 + Math.sin(elapsed * 3) * 0.1;
                } else if (unit.type === 'boss') {
                    mesh.rotation.y = Math.sin(elapsed) * 0.05;
                    if (mesh.children[5]) mesh.children[5].rotation.x = Math.sin(elapsed * 2) * 0.2;
                    if (mesh.children[6]) mesh.children[6].rotation.x = -Math.sin(elapsed * 2) * 0.2;
                }

                if (unit.state === 'fighting') {
                    mesh.position.x += Math.sin(elapsed * 30) * 0.05;
                }
            });
        }

        // ==================== SKILLS ====================
        function selectSkill(skill) {
            const skills = gameState.players.commander.skills;

            if (skill === 'boss') {
                if (!skills.boss.ready) return;
                // Boss doesn't need targeting
                if (useSkillBoss(gameState)) {
                    broadcast({ type: 'skill', skill: 'boss' });
                }
                return;
            }

            if (!skills[skill].ready) return;

            selectedSkill = skill;
            document.querySelectorAll('.skill-btn').forEach(el => el.classList.remove('active'));
            document.querySelector(`[data-skill="${skill}"]`).classList.add('active');
            document.getElementById('selectedSkill').classList.remove('hidden');
            document.getElementById('selectedSkill').textContent = `Click to deploy ${skill.toUpperCase()}`;
        }

        function useSelectedSkill(x, y) {
            if (!selectedSkill) return;

            let success = false;
            switch (selectedSkill) {
                case 'hero':
                    success = useSkillHero(gameState, x, y);
                    break;
                case 'turret':
                    success = useSkillTurret(gameState, x, y);
                    break;
                case 'meteor':
                    success = useSkillMeteor(gameState, x, y);
                    break;
            }

            if (success) {
                broadcast({ type: 'skill', skill: selectedSkill, x: x, y: y });
                selectedSkill = null;
                document.querySelectorAll('.skill-btn').forEach(el => el.classList.remove('active'));
                document.getElementById('selectedSkill').classList.add('hidden');
            }
        }

        // ==================== INPUT ====================
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Digit1') selectSkill('hero');
            if (e.code === 'Digit2') selectSkill('turret');
            if (e.code === 'Digit3') selectSkill('meteor');
            if (e.code === 'Digit4') selectSkill('boss');
            if (e.code === 'Escape') {
                selectedSkill = null;
                document.querySelectorAll('.skill-btn').forEach(el => el.classList.remove('active'));
                document.getElementById('selectedSkill').classList.add('hidden');
            }
        });

        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (selectedSkill) {
                raycaster.setFromCamera(mouse, camera);
                const hits = raycaster.intersectObjects(gridMeshes.flat());
                if (hits.length > 0) {
                    const hit = hits[0];
                    targetMarker.position.x = hit.object.position.x;
                    targetMarker.position.z = hit.object.position.z;
                    targetMarker.visible = true;
                }
            } else {
                targetMarker.visible = false;
            }
        });

        document.addEventListener('click', (e) => {
            if (!selectedSkill) return;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(gridMeshes.flat());

            if (hits.length > 0) {
                const { gridX, gridY } = hits[0].object.userData;
                useSelectedSkill(gridX, gridY);
            }
        });

        // ==================== UI ====================
        function updateUI() {
            // Timer
            const minutes = Math.floor(gameState.timeRemaining / 60);
            const seconds = Math.floor(gameState.timeRemaining % 60);
            const timerEl = document.getElementById('timer');
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            timerEl.className = gameState.timeRemaining < 60 ? 'warning' : '';

            // Stats
            document.getElementById('killCount').textContent = gameState.stats.playerKills;
            document.getElementById('unitCount').textContent = gameState.units.player.length;

            // Skills cooldowns
            const skills = gameState.players.commander.skills;

            ['hero', 'turret', 'meteor'].forEach(skill => {
                const cdEl = document.getElementById(skill + 'Cd');
                const btnEl = document.querySelector(`[data-skill="${skill}"]`);
                if (!skills[skill].ready) {
                    cdEl.classList.remove('hidden');
                    cdEl.textContent = Math.ceil(skills[skill].cooldown);
                    btnEl.classList.add('disabled');
                } else {
                    cdEl.classList.add('hidden');
                    btnEl.classList.remove('disabled');
                }
            });

            // Boss skill
            const bossBtn = document.querySelector('[data-skill="boss"]');
            const bossCd = document.getElementById('bossCd');
            if (skills.boss.ready && !gameState.boss.player) {
                bossBtn.classList.remove('locked');
                bossCd.classList.add('hidden');
            } else {
                bossBtn.classList.add('locked');
                bossCd.classList.remove('hidden');
                bossCd.textContent = gameState.boss.player ? '‚úì' : 'üîí';
            }

            // Ultimate gauge
            const gauge = gameState.players.commander.ultimateGauge;
            document.getElementById('ultimateFill').style.width = gauge + '%';
            document.getElementById('ultimatePercent').textContent = Math.floor(gauge) + '%';

            // Territory
            const total = GAME_CONFIG.GRID_WIDTH * GAME_CONFIG.GRID_HEIGHT;
            const playerPct = Math.round(gameState.stats.playerTiles / total * 100);
            const enemyPct = Math.round(gameState.stats.enemyTiles / total * 100);
            document.getElementById('playerTerritory').style.width = playerPct + '%';
            document.getElementById('playerTerritory').textContent = playerPct + '%';
            document.getElementById('enemyTerritory').style.width = enemyPct + '%';
            document.getElementById('enemyTerritory').textContent = enemyPct + '%';
        }

        function showGameOver() {
            const won = gameState.stats.playerTiles > gameState.stats.enemyTiles;
            document.getElementById('resultTitle').textContent = won ? 'VICTORY!' : 'DEFEAT';
            document.getElementById('resultTitle').style.color = won ? '#2ecc71' : '#e74c3c';
            const total = GAME_CONFIG.GRID_WIDTH * GAME_CONFIG.GRID_HEIGHT;
            const pct = Math.round(gameState.stats.playerTiles / total * 100);
            document.getElementById('resultText').textContent = `Your team controls ${pct}%`;
            document.getElementById('gameOver').classList.remove('hidden');
        }

        // ==================== GAME LOOP ====================
        let lastTime = 0;
        let spawnTimer = 0;

        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (!gameState.gameEnded) {
                // Only run game logic if NOT connected to host
                // Host (vanguard) is authoritative
                if (!isConnectedToHost) {
                    updateGame(gameState, deltaTime);

                    spawnTimer += deltaTime;
                    if (spawnTimer >= GAME_CONFIG.MINION_SPAWN_INTERVAL) {
                        spawnTimer = 0;
                        spawnPlayerMinions(gameState);
                        spawnEnemyMinions(gameState);
                    }

                    updateAI(gameState, deltaTime);
                } else {
                    // Still update local skill cooldowns
                    Object.keys(gameState.players.commander.skills).forEach(skill => {
                        const s = gameState.players.commander.skills[skill];
                        if (!s.ready && s.cooldown > 0) {
                            s.cooldown -= deltaTime;
                            if (s.cooldown <= 0) {
                                s.cooldown = 0;
                                if (skill !== 'boss') s.ready = true;
                            }
                        }
                    });

                    // Check ultimate gauge from synced stats
                    const gauge = gameState.stats.playerKills + (gameState.stats.playerTiles / 7);
                    gameState.players.commander.ultimateGauge = Math.min(100, gauge);
                    if (gameState.players.commander.ultimateGauge >= 100 && !gameState.boss.player) {
                        gameState.players.commander.skills.boss.ready = true;
                    }
                }

                updateGrid();
                updateUnitsVisual();
                updateUI();
            } else {
                showGameOver();
            }

            renderer.render(scene, camera);
        }

        // ==================== RESIZE ====================
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            const aspect = window.innerWidth / window.innerHeight;
            const viewHeight = GAME_CONFIG.GRID_HEIGHT * GAME_CONFIG.CELL_SIZE / 2 + 5;
            const viewWidth = viewHeight * aspect;
            camera.left = -viewWidth;
            camera.right = viewWidth;
            camera.top = viewHeight;
            camera.bottom = -viewHeight;
            camera.updateProjectionMatrix();
        });

        // ==================== INIT ====================
        initThreeJS();
        initNetworking();
    </script>
</body>
</html>
